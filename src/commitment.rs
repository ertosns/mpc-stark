//! Pedersen commitment implementation, borrowed from
//! https://github.com/dalek-cryptography/bulletproofs/blob/main/src/generators.rs#L29

use curve25519_dalek::{
    constants::{RISTRETTO_BASEPOINT_POINT, RISTRETTO_BASEPOINT_COMPRESSED},
    ristretto::RistrettoPoint, 
    scalar::Scalar, traits::MultiscalarMul, 
};
use rand_core::OsRng;
use sha3::{Sha3_512};

/// Implementation of a Pedersen commitment scheme, modified from:
/// https://github.com/dalek-cryptography/bulletproofs/blob/main/src/generators.rs#L29
#[allow(non_snake_case)]
#[derive(Copy, Clone)]
pub struct PedersenGens {
    /// Base for the committed value
    pub B: RistrettoPoint,
    /// Base for the blinding factor
    pub B_blinding: RistrettoPoint,
}

impl PedersenGens {
    /// Creates a Pedersen commitment using the value scalar and a blinding factor.
    pub fn commit(&self, value: Scalar, blinding: Scalar) -> RistrettoPoint {
        RistrettoPoint::multiscalar_mul(&[value, blinding], &[self.B, self.B_blinding])
    }
}

impl Default for PedersenGens {
    fn default() -> Self {
        PedersenGens {
            B: RISTRETTO_BASEPOINT_POINT,
            B_blinding: RistrettoPoint::hash_from_bytes::<Sha3_512>(
                RISTRETTO_BASEPOINT_COMPRESSED.as_bytes(),
            ),
        }
    }
}

/// Represents a Pedersen commitment to and underlying value
#[derive(Clone, Debug)]
pub struct PedersenCommitment {
    /// The commitment to x generated by xG + rH for randomness r
    commitment: RistrettoPoint,
    /// The blinding factor `r` used in commitment generation
    blinding_factor: Scalar,
    /// The underlying value `x` that has been comitted to
    value: Scalar,
}

impl PedersenCommitment {
    /// Fetch the commitment
    #[inline]
    pub fn get_commitment(&self) -> RistrettoPoint {
        self.commitment
    }

    /// Create a Pedersen commitment to a value
    pub fn commit(value: Scalar) -> PedersenCommitment {
        // Sample a secure random blinding scalar
        let mut rng = OsRng{};
        let blinding_factor = Scalar::random(&mut rng);

        Self {
            commitment: PedersenGens::default().commit(value, blinding_factor),
            blinding_factor,
            value,
        }
    }

    /// Verify a commitment
    pub fn verify(&self) -> bool {
        PedersenCommitment::verify_from_values(self.commitment, self.blinding_factor, self.value)
    }

    /// A convenience method for verifying a commitment that does not require the user to
    /// build a PedersenCommitment instance
    pub fn verify_from_values(commitment: RistrettoPoint, blinding_factor: Scalar, value: Scalar) -> bool {
        PedersenGens::default().commit(value, blinding_factor).eq(&commitment)
    }
}

#[cfg(test)]
mod tests {
    use curve25519_dalek::scalar::Scalar;
    use rand_core::OsRng;

    use super::PedersenCommitment;

    #[test]
    fn test_commit_and_open() {
        // Commit to a random value, open it correctly, then attempt to open it incorrectly
        let mut rng = OsRng{};
        let value = Scalar::random(&mut rng);
        let bad_value = Scalar::random(&mut rng);

        let commitment = PedersenCommitment::commit(value);
        assert!(commitment.verify());
        assert!(
            !PedersenCommitment::verify_from_values(commitment.commitment, commitment.blinding_factor, bad_value)
        )
    }
}